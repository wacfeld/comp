
void splice(char *src)
{
  /* int len = strlen(src); */
  int c = 0, i = 0;
  while(src[i])
  {
    if(src[i] == '\\' && src[i+1] == '\n')
    {
      i += 2;
      
    }
    else
    {
      src[c++] = src[i];
      i++;
    }
  }
  src[c] = 0;
}


int xtod(char c)
{
  if(isdigit(c))
    return c - '0';

  return tolower(c) - 'a' + 10;
}



void unesc(char *src)
{
  /* int len = strlen(src); */
  int c = 0;
  int i = 0;
  while(src[i])
  {
    if(src[i] == '\\')
    {
      if(src[i+1] == '\\')
      {
        src[c++] = '\\';
        i += 2;
      }
      else if(src[i+1] == 'n')
      {
        src[c++] = '\n';
        i += 2;
      }
      else if(src[i+1] == 't')
      {
        src[c++] = '\t';
        i += 2;
      }
      else if(src[i+1] == 'v')
      {
        src[c++] = '\v';
        i += 2;
      }
      else if(src[i+1] == 'b')
      {
        src[c++] = '\b';
        i += 2;
      }
      else if(src[i+1] == 'r')
      {
        src[c++] = '\r';
        i += 2;
      }
      else if(src[i+1] == 'f')
      {
        src[c++] = '\f';
        i += 2;
      }
      else if(src[i+1] == 'a')
      {
        src[c++] = '\a';
        i += 2;
      }
      else if(src[i+1] == '?')
      {
        src[c++] = '\t';
        i += 2;
      }
      else if(src[i+1] == '\'')
      {
        src[c++] = '\'';
        i += 2;
      }
      else if(src[i+1] == '"')
      {
        src[c++] = '"';
        i += 2;
      }
      else if(isdigit(src[i+1])) 
      {
        int numlen = 1;
        int num = 0;
        while(isdigit(src[i+numlen]) && numlen <= 3)
        {
          num *= 8;
          num += src[i+numlen] - '0';
          numlen++;
        }

        assert(num <= CHAR_MAX);
        src[c++] = num;
        i += numlen;
      }
      else if(src[i+1] == 'x') 
      {
        int numlen = 1;
        int num = 0;
        while(isxdigit(src[i+numlen+1]))
        {
          num *= 16;
          num += xtod(src[i+numlen+1]);
          numlen++;
        }

        assert(num <= CHAR_MAX);
        src[c++] = num;
        i += numlen+1;
      }
      else
      {
        assert(!"invalid escape sequence");
      }
    }
    else
    {
      src[c++] = src[i];
      i++;
    }
  }

  src[c] = 0;
}


void mark_esc(char *src, char *esc)
{
  int i;
  /* int len = strlen(src); */
  for(i = 0; src[i]; i++) 
  {
    esc[i] = 0;
  }

  /*
    following splice(), the only backslashes must be in char/string literals
    we can mark these, so that we know which single/double quotes to ignore later
    then once we have determined string/char literals, we can search again for stray backslashes
  */
  i = 0;
  while(src[i])
  {
    if(src[i] == '\\')
    {
      esc[i] = 1;
      esc[i+1] = 1;
      
      i += 2;
    }
    else
      i++;
  }
}



void mark_quot(char *src, char *esc, char *quot)
{
  int i;
  /* int len = strlen(src); */
  for(i = 0; src[i]; i++) 
  {
    quot[i] = 0;
  }

  char curquot = 0; 
  for(i = 0; src[i]; i++)
  {
    quot[i] = curquot;

    if((src[i] == '"' || src[i] == '\'') && !esc[i]) 
    {
      if(curquot == 0) 
      {
        curquot = src[i];
      }
      else if(curquot == src[i]) 
      {
        curquot = 0;
        quot[i] = 0;
      }
      
    }
  }
}


void stray_backslash(char *src, char *esc, char *quot)
{
  for(int i = 0; src[i]; i++)
  {
    assert(src[i] != '\\' || quot[i]);
  }
}


void rem_comments(char *src, char *esc, char *quot)
{
  int i = 0, c = 0;
  int incomment = 0;
  while(src[i])
  {
    if(src[i] == '/' && src[i+1] == '*' && !quot[i] && !quot[i+1]) 
    {
      incomment = 1;
      i += 2; 
    }
    else if(incomment && src[i] == '*' && src[i+1] == '/') 
    {
      incomment = 0;
      src[c] = ' '; 
      esc[c] = 0;
      quot[c] = 0;
      i += 2;
      c++;
    }

    else if(!incomment) 
    {
      src[c] = src[i];
      quot[c] = quot[i];
      esc[c] = esc[i];
      c++;
      i++;
    }
    else 
      i++;
  }

  assert(!incomment); 
  src[c] = 0; 
  
}


void puttok(token t)
{
  if(t.gen.type == NOTOK)
  {
    printf("%s ", hrtok[t.gen.type]);
  }
  if(t.gen.type == ATOM)
  {
    printf("%s ", hrat[t.atom.cont]);
  }
  if(t.gen.type == FLOATING)
    printf("%f ", t.floating.cont);
  if(t.gen.type == STRLIT || t.gen.type == IDENT)
    printf("%s ", t.strlit.cont);
  if(t.gen.type == KEYWORD)
  {
    printf("%s ", keywords[t.keyword.cont]);
  }
  if(t.gen.type == CHAR)
    printf("%c ", t.character.cont);
  if(t.gen.type == INTEGER)
  {
    printf("%d ", t.integer.cont);
  }
  newl();
}





token *nextstat(char *src, char *esc, char *quot)
{
}


int isletter(char c)
{
  return (isalpha(c) || c == '_'); 
}


int striskeyword(char *s)
{
  static int len = sizeof(keywords) / sizeof(char *);

  for(int i = 0; i < len; i++)
  {
    if(!strcmp(keywords[i], s))
    {
      return i;
    }
  }
  return -1;
}


int isintsuffix(char c)
{
  return c == 'l' || c == 'L' || c == 'u' || c == 'U';
}

int isfloatsuffix(char c)
{
  return c == 'l' || c == 'L' || c == 'f' || c == 'F';
}


token * nexttok(char *src, char *esc, char *quot)
{
  

  token *t = malloc(sizeof(token));
  static int i = 0;

  if(src == NULL) 
  {
    i = 0;
    
    return t;
  }

  while(isspace(src[i])) i++; 

  if(!src[i]) 
  {
    t->gen.type = NOTOK;
    return t; 
  }
  
  alloc(char, str, size, c);

  if(src[i] == '.' && isdigit(src[i+1])) 
  {
    goto leaddot; 
  }
  else if(isletter(src[i])) 
  {

    

    
    while(isletter(src[i]) || isdigit(src[i]))
    {
      str[c++] = src[i++];
      resize(str, size, c);

    }
    str[c] = 0;

    if(!strcmp(str, "sizeof")) 
    {
      t->gen.type = ATOM;
      t->atom.cont = SIZEOF;
      return t;
    }

    int k;
    if((k = striskeyword(str)) != -1) 
    {
      t->gen.type = KEYWORD;
      t->keyword.cont = k;
    }
    else 
    {
      t->gen.type = IDENT;
      t->ident.cont = str;
    }

    return t;
  }

  else if(isdigit(src[i])) 
  {
    str[c++] = src[i++]; 
    resize(str, size, c);

    

    if(isdigit(src[i]) || src[i] == 'x' || src[i] == 'X') 
    {
      str[c++] = src[i++]; 
      resize(str, size, c);
    }

    while(isxdigit(src[i])) 
    {
      str[c++] = src[i++];
      resize(str, size, c);
    }

    /*
operators/delimiters:
      !%&()*+,-./:;<=>?[]^{|}~
quotes:
      "'
banned:
      #$@\`
digits:
      0123456789
letters:
      ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_
whitespace:

       */

    
    
    if(src[i] != '.') 
    {
      str[c] = 0; 

      t->gen.type = INTEGER;
      t->integer.isunsigned = 0;
      t->integer.islong = 0;

      if(isletter(src[i])) 
      {
        char s1 = tolower(src[i]);
        if(isletter(src[i+1])) 
        {
          char s2 = tolower(src[i+1]);
          assert((s1 == 'u' && s2 == 'l') || (s1 == 'l' && s2 == 'u')); 
          t->integer.isunsigned = 1;
          t->integer.islong = 1;

          i += 2;
        }
        else if(s1 == 'u')
        {
          t->integer.isunsigned = 1;
          i++;
        }
        else if(s1 == 'l')
        {
          t->integer.islong = 1;
          i++;
        }
        else
          assert(!"invalid integer suffix");
      }

      
      u_int32_t num = 0;

      assert(tolower(str[1]) != 'x' || str[2] != 0);
      int i = 0; 
      
      int base = 10;
      if(str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
      {
        base = 16;
        i += 2;
      }
      else if(str[0] == '0') 
        base = 8;

      
      while(str[i])
      {
        num *= base;
        num += xtod(str[i]); 
        i++;
      }

      free(str); 

      t->integer.cont = num;

      return t;
    }

    else if(src[i] == '.') 
    {
leaddot:
      str[c++] = src[i++]; 
      resize(str, size, c);

      t->gen.type = FLOATING;
      t->floating.isshort = 0;
      t->floating.islong = 0;

      while(isdigit(src[i])) 
      {
        str[c++] = src[i++];
        resize(str, size, c);
      }

      if(src[i] == 'e' || src[i] == 'E') 
      {
        str[c++] = src[i++]; 
        resize(str, size, c);

        if(src[i] == '+' || src[i] == '-') 
        {
          str[c++] = src[i++]; 
          resize(str, size, c);
        }

        assert(isdigit(src[i])); 
        while(isdigit(src[i])) 
        {
          str[c++] = src[i++];
          resize(str, size, c);
        }
      }

      str[c] = 0; 
      
      char suf = 0;
      if(isfloatsuffix(src[i]))
      {
        
        suf = tolower(src[i]);
        i++;
      }
      else assert(!isletter(src[i])); 

      
      

      float num;
      if(suf == 'f') 
      {
        sscanf(str, "%f", &num);
        t->floating.cont = num;

        t->floating.isshort = 1;
      }
      else if(suf == 'l') 
      {
        sscanf(str, "%f", &num);
        t->floating.cont = num;

        t->floating.islong = 1;
      }
      else 
      {
        sscanf(str, "%f", &num);
        t->floating.cont = num;
      }

      free(str); 
      
      return t;
    }

    assert(!"this assert should never run");
  }

  else if(src[i] == '"') 
  {
    i++; 

    
    while(quot[i])
    {
      str[c++] = src[i++];
      resize(str, size, c);

      
      
      
      
      
    }
    str[c] = 0;
    i++; 

    unesc(str); 
    
    t->gen.type = STRLIT;
    t->strlit.cont = str;

    return t;
  }

  else if(src[i] == '\'') 
  {
    i++; 

    
    while(quot[i])
    {
      str[c++] = src[i++];
      resize(str, size, c);

      
      
      
      
      
    }
    str[c] = 0;
    i++; 

    unesc(str); 
    assert(strlen(str) == 1); 

    char chr;
    chr = str[0];
    
    t->gen.type = CHAR;
    t->character.cont = chr;

    return t;
  }

  else if(src[i] == ';') 
  {
    t->gen.type = ATOM;
    t->atom.cont = SEMICOLON;
    i++;
    return t;
  }

  
  else if(src[i] == '(') 
  {
    t->gen.type = ATOM;
    t->atom.cont = PARENOP;
    i++;
    return t;
  }
  else if(src[i] == ')') 
  {
    t->gen.type = ATOM;
    t->atom.cont = PARENCL;
    i++;
    return t;
  }
  else if(src[i] == '{')
  {
    t->gen.type = ATOM;
    t->atom.cont = BRACEOP;
    i++;
    return t;
  }
  else if(src[i] == '}')
  {
    t->gen.type = ATOM;
    t->atom.cont = BRACECL;
    i++;
    return t;
  }
  else if(src[i] == '[')
  {
    t->gen.type = ATOM;
    t->atom.cont = BRACKOP;
    i++;
    return t;
  }
  else if(src[i] == ']')
  {
    t->gen.type = ATOM;
    t->atom.cont = BRACKCL;
    i++;
    return t;
  }

  
  
  
  
  
  t->gen.type = ATOM; 

  
  
  
  if(src[i] == '-') 
  {
    i++;
    if(src[i] == '>')
    {
      i++;
      t->atom.cont = ARROW;
    }
    else if(src[i] == '-')
    {
      i++;
      t->atom.cont = DEC;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = MINEQ;
    }
    else
      t->atom.cont = MIN; 
  }

  else if(src[i] == '.') 
  {
    i++;
    t->atom.cont = DOT;
  }

  else if(src[i] == '!') 
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = NOTEQ;
    }
    else
      t->atom.cont = LOGNOT;
  }

  else if(src[i] == '~')
  {
    i++;
    t->atom.cont = BITNOT;
  }

  else if(src[i] == '+') 
  {
    i++;
    if(src[i] == '+')
    {
      i++;
      t->atom.cont = INC;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = PLUSEQ;
    }
    else
      t->atom.cont = PLUS; 
  }

  else if(src[i] == '*') 
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = TIMESEQ;
    }
    else
      t->atom.cont = STAR; 
  }

  else if(src[i] == '/') 
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = DIVEQ;
    }
    else
      t->atom.cont = DIV;
  }

  else if(src[i] == '%') 
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = MODEQ;
    }
    else
      t->atom.cont = MOD;
  }

  else if(src[i] == '<') 
  {
    i++;
    if(src[i] == '<')
    {
      i++;
      if(src[i] == '=')
      {
        i++;
        t->atom.cont = SHLEQ;
      }
      else
        t->atom.cont = SHL;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = LEQ;
    }
    else
      t->atom.cont = LESS;
  }

  else if(src[i] == '>') 
  {
    i++;
    if(src[i] == '>')
    {
      i++;
      if(src[i] == '=')
      {
        i++;
        t->atom.cont = SHREQ;
      }
      else
        t->atom.cont = SHR;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = GEQ;
    }
    else
      t->atom.cont = GREAT;
  }

  else if(src[i] == '=') 
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = EQEQ;
    }
    else
      t->atom.cont = EQ;
  }

  else if(src[i] == '&') 
  {
    i++;
    if(src[i] == '&')
    {
      i++;
      t->atom.cont = LOGAND;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = ANDEQ;
    }
    else
      t->atom.cont = BITAND;
  }

  else if(src[i] == '|') 
  {
    i++;
    if(src[i] == '|')
    {
      i++;
      t->atom.cont = LOGOR;
    }
    else if(src[i] == '=')
    {
      i++;
      t->atom.cont = OREQ;
    }
    else
      t->atom.cont = BITOR;
  }

  else if(src[i] == '^')
  {
    i++;
    if(src[i] == '=')
    {
      i++;
      t->atom.cont = XOREQ;
    }
    else
      t->atom.cont = BITXOR;
  }

  else if(src[i] == ',') 
  {
    i++;
    t->atom.cont = COMMA;
  }

  else if(src[i] == ':') 
  {
    i++;
    t->atom.cont = COLON;
  }

  else if(src[i] == '?') 
  {
    i++;
    t->atom.cont = QUESTION;
  }
  
  return t;
  /*
  floats can start with dots
  colons can be for labels
  parens/braces can be many things
  ternary operators
  minus sign can be arrow operator
     */


}

void check_stray(char *src, char *esc, char *quot, char *banned)
{
  int i;
  for(i = 0; src[i]; i++)
  {
    assert(strchr(banned, src[i]) == NULL || quot[i]);
  }
}

int iskeyword(token *t, enum keyword k)
{
  return t->gen.type == KEYWORD && t->keyword.cont == k;
}
int isatom(token *t, enum atom_type a)
{
  return t->gen.type == ATOM && t->atom.cont == a;
}


int gettypespec(token t) 
{
  if(t.gen.type == KEYWORD)
  {
    enum keyword k = t.keyword.cont;
    if(k == K_VOID || k == K_CHAR || k == K_SHORT || k == K_INT || k == K_LONG || k == K_FLOAT || k == K_DOUBLE || k == K_SIGNED || k == K_UNSIGNED)
    {
      return k;
    }
    else return -1;
  }
  
  else return -1;

}

int gettypequal(token t) 
{
  if(t.gen.type == KEYWORD)
  {
    enum keyword k = t.keyword.cont;
    if(k == K_VOLATILE || k == K_CONST)
    {
      return k;
    }
    else return -1;
  }
  return -1;
}

int getstorespec(token t) 
{
  if(t.gen.type == KEYWORD)
  {
    enum keyword k = t.keyword.cont;
    if(k == K_AUTO || k == K_REGISTER || k == K_STATIC || k == K_EXTERN || k == K_TYPEDEF)
    {
      return k;
    }
    return -1;
  }
  return -1;
}


















int gettypemods(token *toks, int lo, int hi, list *l)
{
  
  
  if(hi == -1)
  {
    hi = lo; 
    int parendep = 0;
    
    for(;; hi++) 
    {
      if(isatom(toks+hi, STAR))
      {
        continue;
      }
      if(isatom(toks+hi, PARENOP)) 
      {
        parendep++;
        continue;
      }
      if(iskeyword(toks+hi, K_VOLATILE) || iskeyword(toks+hi, K_CONST))
      {
        continue;
      }

      
      break;
    }
    assert(toks[hi].gen.type == IDENT); 
    hi++; 
    

    
    for(;;) 
    {
      if(isatom(toks+hi, PARENCL)) 
      {
        parendep--;
        assert(parendep >= 0); 
        hi++;
        continue;
      }

      if(isatom(toks+hi, BRACKOP)) 
      {
        
        
        int brackdep = 0;
        do
        {
          if(isatom(toks+hi, BRACKOP)) brackdep++;
          if(isatom(toks+hi, BRACKCL)) brackdep--;
          assert(parendep >= 0 && toks[hi].gen.type != NOTOK);
          hi++;
        } while(brackdep);

        continue;
      }

      if(isatom(toks+hi, PARENOP)) 
      {
        
        int curdep = parendep;
        do
        {
          if(isatom(toks+hi, PARENOP)) parendep++;
          if(isatom(toks+hi, PARENCL)) parendep--;
          assert(parendep >= 0 && toks[hi].gen.type != NOTOK);
          hi++;
        } while(curdep != parendep);

        continue;
      }

      assert(parendep == 0); 
      hi--; 
      break;
    }
  }

  typemod *tmod = malloc(sizeof(typemod));

  if(isatom(toks+lo, STAR)) 
  {
    tmod->gen.type = TM_PTR;

    
    lo++;
    for(;; lo++)
    {
      if(iskeyword(toks+lo, K_VOLATILE))
      {
        tmod->ptr.isvolatile = 1;
      }
      else if(iskeyword(toks+lo, K_CONST))
      {
        tmod->ptr.isconst = 1;
      }
      else 
        break;
    }

    append(l, tmod);
    free(tmod);
    gettypemods(toks, lo, hi, l);

    return hi+1;
  }
  
  if(isatom(toks+lo, PARENOP) || toks[lo].gen.type == IDENT) 
  {
    if(isatom(toks+hi, PARENCL)) 
    {
      
      int parendep = 0;
      int i = hi; 
      do
      {
        if(isatom(toks+i, PARENCL)) parendep++;
        if(isatom(toks+i, PARENOP)) parendep--;
        assert(parendep >= 0 && i >= 0);
        i--;
      } while(parendep != 0);
      i++; 

      if(i == lo) 
      {
        
        free(tmod); 
        gettypemods(toks, lo+1, hi-1, l);

        return hi+1;
      }

      else 
      {
        tmod->gen.type = TM_FUNC;
        
        append(l, tmod);
        free(tmod);
        gettypemods(toks, lo, i-1, l);
        
        return hi+1;
      }
    }

    if(isatom(toks+hi, BRACKCL)) 
    {
      
      int brackdep = 0;
      int i = hi;
      do
      {
        if(isatom(toks+i, BRACKCL)) brackdep++;
        if(isatom(toks+i, BRACKOP)) brackdep--;
        assert(brackdep >= 0 && i >= 0);
        i--;
      } while(brackdep != 0);
      i++; 

      
      tmod->gen.type = TM_ARR;
      append(l, tmod);
      free(tmod);
      gettypemods(toks, lo, i-1, l);

      return hi+1;
    }

    
    
    
    assert(lo == hi);
    assert(toks[lo].gen.type == IDENT);

    tmod->gen.type = TM_IDENT;
    tmod->ident.name = toks[lo].ident.cont;

    append(l, tmod);
    free(tmod);

    return hi+1;
  }
}

void puttypemod(typemod ts)
{
  enum tmt type = ts.gen.type;
  if(type == TM_IDENT)
  {
    printf("%s is a ", ts.ident.name);
  }
  if(type == TM_PTR)
  {
    if(ts.ptr.isconst)
      printf("constant ");
    if(ts.ptr.isvolatile)
      printf("volatile ");
    printf("pointer to ");
  }
  if(type == TM_ARR)
  {
    printf("array of ");
  }
  if(type == TM_FUNC)
  {
    printf("function returning ");
  }
}




int parsedecl(token *toks)
{
  
  
  static int i = 0;

  if(!toks) 
  {
    i = 0;
    return 1; 
  }

  if(toks[i].gen.type == NOTOK) 
  {
    return 0;
  }
  
  
  set *typespecs  = makeset(sizeof(int));
  set *typequals  = makeset(sizeof(int));
  set *storespecs = makeset(sizeof(int));

  int n = i; 
  token t;
  int spec;
  
  for(;; i++)
  {
    t =toks[i];
    if((spec = gettypespec(t)) != -1)
    {
      
      assert(!setins(typespecs, &spec)); 
    }
    else if((spec = gettypequal(t)) != -1)
    {
      setins(typequals, &spec); 
    }
    else if((spec = getstorespec(t)) != -1)
    {
      assert(!setins(storespecs, &spec)); 
    }
    else break; 
  }
  
  
  /*
    auto and register only in functions
    conflicting type specifiers
    only one storage class allowed
    typedef must be at beginning of declaration
    functions inside a function are extern, functions declared outside are static with external linkage
    etc.
    static objects/arrays must be initialized with constant expressions
    technically, list members must be constant expressions even if auto or register
     */

  int temp = K_TYPEDEF; 
  if(inset(storespecs, &temp)) 
  {
    
  }

  

  

  

  

  list *l = makelist(sizeof(typemod));
  i = gettypemods(toks, i, -1, l); 
  reverse(l); 

  typemod *tms = (typemod *) l->cont;
  int tmlen = l->n;
  for(int j = 0; j < tmlen; j++)
  {
    puttypemod(tms[j]);
  }
  int *tss = (int *) typespecs->cont;
  int tslen = typespecs->n;
  for(int j = 0; j < tslen; j++)
  {
    printf("%s ", keywords[tss[j]]);
  }
  newl();


  ctype ct = {typespecs, typequals, storespecs, l};

  

  
  if(isatom(toks+i, BRACEOP))
  {
    
    
    puts("(function definition)");
    int bracedep = 0;
    do
    {
      if(isatom(toks+i, BRACEOP)) bracedep++;
      if(isatom(toks+i, BRACECL)) bracedep--;
      i++;
    } while(bracedep);
  }

  else if(isatom(toks+i, EQ)) 
  {
    
    puts("(initialization)");
    while(!isatom(toks+i, SEMICOLON)) i++;
  }

  else assert(isatom(toks+i, SEMICOLON));
  i++; 

  return 1; 
}


int main()
{
  

  assert(sizeof(float) == 4); 

  
  
  alloc(char, src, srcsize, i);

  int c;

  while((c = getchar()) != EOF) 
  {
    src[i++] = c;
    resize(src, srcsize, i);
  }
  src[i] = 0; 

  char *quot = malloc(i);
  char *esc = malloc(i);

  splice(src); 

  mark_esc(src, esc); 
  mark_quot(src, esc, quot); 

  rem_comments(src, esc, quot); 

  
  check_stray(src, esc, quot, "#$@\\`"); 

  
  

  list *trans_unit = makelist(sizeof(token));

  
  do
  {
    
    token *t = nexttok(src, esc, quot);
    append(trans_unit, t);
    free(t);
    
    
    puttok(*(token *)last(trans_unit));

  }
  while(((token *)last(trans_unit))->gen.type != NOTOK);

  puts("------------------");
  while(parsedecl((token *)trans_unit->cont)); 

  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  





  
  
  
  
  
  
  
  
  
  
  
  

  

  

  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
  
  
  
  

  
  
  
  
  

  
  

  

  
  
  
  






  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

}
